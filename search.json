[{"title":"JavaWeb学习（一）","url":"/2020/09/20/JavaWeb%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/","content":"一、基本概念1.1、WEB开发的相关知识　　WEB，在英语中web即表示网页的意思，它用于表示Internet主机上供外界访问的资源。　　Internet上供外界访问的Web资源分为：\n\n静态web资源（如html 页面）：指web页面中供人们浏览的数据始终是不变。\n动态web资源：指web页面中供人们浏览的数据是由程序产生的，不同时间点访问web页面看到的内容各不相同。\n\n\n静态web资源开发技术：Html\n常用动态web资源开发技术：JSP/Servlet、ASP、PHP等\n在Java中，动态web资源开发技术统称为Javaweb。\n\n1.2、WEB应用程序　WEB应用程序指供浏览器访问的程序，通常也简称为web应用。例如有a.html 、b.html…..多个web资源，这多个web资源用于对外提供服务，此时应把这多个web资源放在一个目录中，以组成一个web应用（或web应用程序）　　一个web应用由多个静态web资源和动态web资源组成，如:html、css、js文件，Jsp文件、java程序、支持jar包、配置文件等等。　　Web应用开发好后，若想供外界访问，需要把web应用所在目录交给web服务器管理，这个过程称之为虚似目录的映射。\n1.3、WEB发展史　　WEB发展的两个阶段：静态、动态\n1.4、静态WEB　　htm、html，这些是网页的后缀，如果现在在一个服务器上直接读取这些内容，那么意味着是把这些网页的内容通过网络服务器展现给用户。整个静态WEB操作的过程图如下：\n　　在静态WEB程序中，客户端使用WEB浏览器（IE、FireFox等）经过网络(Network)连接到服务器上，使用HTTP协议发起一个请求（Request），告诉服务器我现在需要得到哪个页面，所有的请求交给WEB服务器，之后WEB服务器根据用户的需要，从文件系统（存放了所有静态页面的磁盘）取出内容。之后通过WEB服务器返回给客户端，客户端接收到内容之后经过浏览器渲染解析，得到显示的效果。\n　　静态WEB中存在以下几个缺点：\n　　1. Web页面中的内容无法动态更新，所有的用户每时每刻看见的内容和最终效果都是一样的。\n　　为了可以让静态的WEB的显示更加好看，可以加入了JavaScript以完成一些页面上的显示特效，但是这些特效都是在客户端上借助于浏览器展现给用户的，所以在服务器上本身并没有任何的变化。\n　实现静态WEB客户端动态效果的手段：\n\nJavaScript\nVBScript在实际的开发中JavaScript使用得最多。\n\n　　2、静态WEB无法连接数据库，无法实现和用户的交互。\n　　使用数据库保存数据是现在大多数系统的选择，因为数据库中可以方便地管理数据，增删改查操作可以使用标准的SQL语句完成。\n1.5、动态WEB　　所谓的动态不是指页面会动，主要的特性的是：“WEB的页面展示效果因时因人而变”，而且动态WEB具有交互性，WEB的页面的内容可以动态更新。整个动态WEB操作的过程图如下：\n\n　　动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器（IE、FireFox等），通过网络(Network)连接到服务器上，使用HTTP协议发起请求（Request），现在的所有请求都先经过一个WEB Server Plugin（服务器插件）来处理，此插件用于区分是请求的是静态资源(.htm或者是.htm)还是动态资源。\n　　如果WEB Server Plugin发现客户端请求的是静态资源(.htm或者是.htm)，则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。\n　　如果WEB Server Plugin发现客户端请求的是动态资源（*.jsp、*.asp/.aspx、.php），则先将请求转交给WEB Container(WEB容器)，在WEB Container中连接数据库，从数据库中取出数据等一系列操作后动态拼凑页面的展示内容，拼凑页面的展示内容后，把所有的展示内容交给WEB服务器，之后通过WEB服务器将内容发送回客户端浏览器进行解析执行。\n1.6、动态WEB应用的实现手段　　动态WEB现在的实现手段非常多，较为常见的有以下几种：\n\nMicrosoft ASP、ASP.NET\nPHP\nJAVA Servlet/JSP\n\n\nMicrosoft ASP、ASP.NET　　微软公司动态WEB开发是比较早的，而且最早在国内最流行的是ASP。ASP就是在HTML语言之中增加了VB脚本，但是标准的开发应用应该是使用ASP+COM，但是实际情况来看，在开发ASP的时候基本上都在一个页面中写上成百上千的代码，页面代码极其混乱。\n\n　　ASP本身有开发平台的限制：Windows+IIS+SQL Server/Access，ASP只能运行在Windows操作系统上，ASP现在基本上已经淘汰，现在基本上都是使用ASP.NET进行开发，ASP.NET在性能有了很大的改善，而且开发迅速，但是依然受限于平台。ASP.NET中主要是使用C#语言。\n\nPHP　　PHP开发速度很快，功能强大，跨平台(平台指的就是运行的操作系统)，而且代码也简单。\n\nServlet/JSP　　这是SUN公司(SUN现在已经被Oracle公司收购)主推的B/S架构的实现语言，是基于JAVA语言发展起来的，因为JAVA语言足够简单，而且很干净。\n\n\n　　Servlet/JSP技术的性能也是非常高的，不受平台的限制，各个平台基本上都可以使用。而且在运行中是使用多线程的处理方式，所以性能非常高。\n　　SUN公司最早推出的WEB技术推出的是Servlet程序，Servlet程序本身使用的时候有一些问题，所有的程序是采用JAVA代码+HTML的方式编写的，即，要使用JAVA输出语句，一行一行地输出所有的HTML代码，之后，SUN公司受到了ASP的启发，发展出了JSP(Java Server Page)，JSP某些代码的编写效果与ASP是非常相似的。这样可以很方便地使一些ASP程序员转向JSP的学习，加大市场的竞争力度。\n二、WEB服务器2.1、WEB服务器简介　　1、Web服务器是指驻留于因特网上某种类型计算机的程序，是可以向发出请求的浏览器提供文档的程序。当Web浏览器（客户端）连到服务器上并请求文件时，服务器将处理该请求并将文件反馈到该浏览器上，附带的信息会告诉浏览器如何查看该文件（即文件类型）。\n　　2、服务器是一种被动程序：只有当Internet上运行在其他计算机中的浏览器发出请求时，服务器才会响应。\n2.2、常见的Web服务器介绍\nWebLogic　　WebLogic是美国bea公司出品的一个application server。BEA WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。是目前应用最广泛的Web服务器，支持J2EE规范，而且不断的完善以适应新的开发要求。\n\nWebSphere　　WebSphere Application Server 是一种功能完善、开放的Web应用程序服务器，是IBM公司电子商务计划的核心部分，它是基于 Java 的应用环境，用于建立、部署和管理 Internet 和 Intranet Web 应用程序。这一整套产品进行了扩展，以适应 Web应用程序服务器的需要，范围从简单到高级直到企业级。\n\n\n\nTomcat　　TomcatTomcat是一个实现了JAVA EE标准的最小的WEB服务器，是Apache 软件基金会的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。因为Tomcat 技术先进、性能稳定，而且开源免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。学习JavaWeb开发一般都使用Tomcat服务器，该服务器支持全部JSP以及Servlet规范。\n\n\nIIS　　Microsoft的Web服务器产品为Internet Information Services （IIS），IIS 是允许在公共Intranet或Internet上发布信息的Web服务器。ⅡS是目前最流行的Web服务器产品之一，很多著名的网站都是建立在ⅡS的平 台上。IIS提供了一个图形界面的管理工具，称为Internet信息服务管理器，可用于监视配置和控制Internet服务。\n　　 IIS是一种Web服务组件，其中包括Web服务器、FTP服务器、NNTP服务器和SMTP服务器，分别用于网页浏览、文件传输、新闻服务和邮件发送等方面，它使得在网络（包括互联网和局域网）上发布信息成了一件很容易的事。它提供ISAPI(Intranet Server API）作为扩展Web服务器功能的编程接口；同时，它还提供一个Internet数据库连接器，可以实现对数据库的查询和更新。\n \n\n学习web开发，需要先安装一台web服务器，然后再在web服务器中开发相应的web资源，供用户使用浏览器访问。\n\n三、搭建JavaWeb应用开发环境——Tomcat服务器3.1、疑问：学习web开发，为什么必须要先装一个WEB服务器？　　在本地计算机上随便创建一个web页面，用户是无法访问到的，但是如果启动tomcat服务器，把web页面放在tomcat服务器中，用户就可以访问了。这说明什么问题？　　1、不管什么web资源，想被远程计算机访问，都必须有一个与之对应的网络通信程序，当用户来访问时，这个网络通信程序读取web资源数据，并把数据发送给来访者。　　2、WEB服务器就是这样一个程序，它用于完成底层网络通迅。使用这些服务器，We应用的开发者只需要关注web资源怎么编写，而不需要关心资源如何发送到客户端手中，从而极大的减轻了开发者的开发工作量。\n3.2、下载和安装Tomcat服务器　　Tomcat官方站点：http://jakarta.apache.org\n　　下载Tomcat安装程序包：http://tomcat.apache.org/\n　　\n 　　\n\ntar.gz文件是Linux操作系统下的安装版本\n\nexe文件是Windows系统下的安装版本\n\nzip文件是Windows系统下的压缩版本\n　　下载完成后，得到的是一个压缩包，将压缩包解压就可以完成Tomcat服务器的安装。\n\n\n　　\n　　将压缩包解压后，就完成了Tomcat服务器的安装。\n　　\n3.3、启动和测试Tomcat服务器用终端（Terminal）直接打开Tomcat了\n进入Tomcat的bin目录下：终端输入cd /Library/Tomcat/bin ，输完回车\n\ncd /Library/Tomcat/bin \n  也可以打开Tomcat文件夹，把bin文件夹直接拖拉到终端，当然前提是先输入cd+空格\n\n授权bin目录下的所有操作：终端输入sudo chmod 755 *.sh，输完回车\n\nsudo chmod 755 *.sh\n\n这时要输入密码，输完回车\n\n这时候就可以开启Tomcat了，终端输入sudo sh ./startup.sh，输完回车\n\n\nsudo sh ./startup.sh\n成功后的终端是这样的\n三、到浏览器输入网址localhost，若出现了下面的画面就证明成功了\n四、关闭Tomcat，用终端输入sh ./shutdown.sh，回车即可关闭\n说明：\n\nsudo为系统超级管理员权限。\nchmod 改变一个或多个文件的存取模式。\n755代表用户对该文件拥有读、写、执行的权限，同组的其他人员拥有执行和读的权限，没有写的权限，其它用户的权限和同组人员一样。\n777代表，user,group ,others ,都有读写和可执行权限。\nchmod -R 777 folername,获取文件夹权限。\n\n","categories":["JavaWeb"],"tags":["JavaWeb"]},{"title":"LeetCode--1052.爱生气的书店老板","url":"/2021/02/23/LeetCode--1052.%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/","content":"Description今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。\n在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。\n书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。\n请你返回这一天营业下来，最多有多少客户能够感到满意的数量。\n\n示例：\n输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3输出：16 解释： 书店老板在最后 3 分钟保持冷静。 感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\n\n提示：\n1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000 0 &lt;= customers[i]&lt;= 1000 0 &lt;= grumpy[i] &lt;= 1\n\nSolution\n先求出老板不生气时候的顾客总数 然后遍历一次customer，i &lt; X就是刚开始取前 X 个大小的窗口先计算，然后接下来每次移动一个单位\n每次窗口的计算可以基于上一个窗口的结果来计算 窗口右移，左边窗口出去一个元素，右边窗口进入一个元素\n对于出窗口的元素，我们要判断在此时老板是否生气grumpy[i-X] == 1，因为只有生气的话，我们出窗口时候才需要减去他，如果不生气的话，就不用减去了\n对于进入窗口的元素，我们也要判断是否老板生气grumpy[i] == 1，只有生气我们才需要加上此时的顾客temp += customers[i]; 最后的结果就是所有窗口中最大值的那个\n\nclass Solution &#123;public:    int maxSatisfied(vector&lt;int&gt;&amp; customers, vector&lt;int&gt;&amp; grumpy, int X)&#123;        int time = customers.size();        int count = 0,max = 0;        for(int i=0;i&lt;time;i++)&#123;            if(grumpy[i]==0)&#123;                  count += customers[i];            &#125;        &#125;        max = count;        for(int i=0;i&lt;time;i++)&#123;            if(i&lt;X)&#123;                if(grumpy[i]==1)&#123;                    count += customers[i];                &#125;            &#125;else&#123;                if(grumpy[i-X]==1)&#123;                    count -= customers[i-X];                &#125;                if(grumpy[i]==1)&#123;                    count += customers[i];                &#125;            &#125;            if(max&lt;count)  max=count;            &#125;        return max;    &#125;&#125;;","categories":["算法"],"tags":["LeetCode","算法"]},{"title":"LeetCode--278. 第一个错误的版本 && 35. 搜索插入位置","url":"/2021/11/14/LeetCode--278.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC%20&&%2035.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/","content":"Description（278. 第一个错误的版本）你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\n假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。\n你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。\n\n示例 1：\n输入：n = 5, bad = 4输出：4解释：调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。\n\n\n示例 2：\n输入：n = 1, bad = 1输出：1\n\nSolution这道题其实也是一个二分查找算法的应用。\n因为给出的描述中，版本错误的规律是如果当前错误，那么错误版本必在前面的版本中，那么应用二分查找就十分符合了。\n还是定义左右边界left 和 right，中界值middle。\n如果isBadVersion(middle)为真，那么缩小范围right = middle。\n否则isBadVersion(middle)，那么缩小范围left = middle + 1。\n最后其实左右边界相等，返回left还是right都可以。\n/** * @param &#123;function&#125; isBadVersion() * @return &#123;function&#125; */var solution = function(isBadVersion) &#123;    /**     * @param &#123;integer&#125; n Total versions     * @return &#123;integer&#125; The first bad version     */    return function(n) &#123;        let left = 1;        let right = n;        while(left &lt; right)&#123;            const middle = Math.floor((right-left)/2 + left);            if(isBadVersion(middle))&#123;                right = middle;            &#125;else&#123;                left = middle + 1;            &#125;        &#125;        return right;    &#125;;&#125;;\n\n\nDescription（35. 搜索插入位置）给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n请必须使用时间复杂度为 O(log n) 的算法。\n\n示例 1:\n输入: nums = [1,3,5,6], target = 5输出: 2\n\n\n示例 2:\n输入: nums = [1,3,5,6], target = 2输出: 1\n\n\n示例 3:\n输入: nums = [1,3,5,6], target = 7输出: 4\n\n\n示例 4:\n输入: nums = [1,3,5,6], target = 0输出: 0\n\n\n示例 5:\n输入: nums = [1], target = 0输出: 0\n\n\n提示:\n1 &lt;= nums.length &lt;= 10^4-10^4 &lt;= nums[i] &lt;= 10^4\nnums 为无重复元素的升序排列数组-10^4 &lt;= target &lt;= 10^4\n\nSolution这可以说是一道很标准的二分算法的题目了。\n一样的思路，通过改变左右的值来控制范围，持续缩小范围，最后锁定数据目标。\nvar searchInsert = function(nums, target) &#123;    const total = nums.length;    let left = 0;    let right = total - 1;    while(left &lt;= right)&#123;        const middle = Math.floor((right-left) / 2 + left);        if(target == nums[middle])&#123;            return middle;        &#125;else if(target &gt; nums[middle])&#123;            left = middle + 1;        &#125;else if(target &lt; nums[middle])&#123;            right = middle - 1;        &#125;    &#125;    return left;&#125;;\n提交上去之后，发现代码其实可以优化一下，if else循坏判断太多，没必要写三个，其实只用两个就可以。\nvar searchInsert = function(nums, target) &#123;    const total = nums.length;    let left = 0;    let right = total - 1;    while(left &lt;= right)&#123;        const middle = Math.floor((right-left) / 2 + left);        if(target &gt; nums[middle])&#123;            left = middle + 1;        &#125;else if(target &lt;= nums[middle])&#123;            right = middle - 1;        &#125;    &#125;    return left;&#125;;\n","categories":["算法"],"tags":["LeetCode","算法"]},{"title":"LeetCode--131.分隔回文串","url":"/2021/03/08/LeetCode-131-%E5%88%86%E9%9A%94%E5%9B%9E%E6%96%87%E4%B8%B2/","content":"Description给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串 。返回 s 所有可能的分割方案。\n回文串:是正着读和反着读都一样的字符串。\n\n示例 1：\n输入：s = “aab” 输出：[[“a”,”a”,”b”],[“aa”,”b”]] \n\n\n示例 2：\n输入：s = “a” 输出：[[“a”]]\n\n\n提示：\n1 &lt;= s.length &lt;= 16 s 仅由小写英文字母组成\n\nSolution思路本题这涉及到两个关键问题：\n切割问题&amp;判断回文\n切割问题，也可以抽象为一颗树形结构，如图：\n\n递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。\n此时可以发现，切割问题的回溯搜索的过程和组合问题的回溯搜索的过程是差不多的。\n回溯三部曲递归函数参数\n全局变量数组path存放切割后回文的子串，二维数组result存放结果集。 （这两个参数可以放到函数参数里）\n\n从前面的树形结构的图中可以看出：切割线切到了字符串最后面，说明找到了一种切割方法，此时就是本层递归的终止终止条件。\n在处理组合问题的时候，递归参数需要传入startIndex，表示下一轮递归遍历的起始位置，这个startIndex就是切割线。\n\n单层搜索的逻辑\n\n在for (int i = startIndex; i &lt; s.size(); i++)循环中，我们定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的子串。\n首先判断这个子串是不是回文，如果是回文，就加入在vector path中，path用来记录切割过的回文子串。\n注意切割过的位置，不能重复切割，所以，backtracking(s, i + 1); 传入下一层的起始位置为i + 1。\n\n判断回文子串\n\n最后我们看一下回文子串要如何判断了，判断一个字符串是否是回文。\n可以使用双指针法，一个指针从前向后，一个指针从后先前，如果前后指针所指向的元素是相等的，就是回文字符串了。\n代码如下：\nclass Solution &#123;private:    vector&lt;vector&lt;string&gt;&gt; result;    vector&lt;string&gt; path; // 放已经回文的子串    void backtracking (const string&amp; s, int startIndex) &#123;        // 如果起始位置已经大于等于s的大小，说明已经找到了一组分割方案了        if (startIndex &gt;= s.size()) &#123;            result.push_back(path);            return;        &#125;        for (int i = startIndex; i &lt; s.size(); i++) &#123;            if (isPalindrome(s, startIndex, i)) &#123;   // 是回文子串                // 获取[startIndex,i]在s中的子串                string str = s.substr(startIndex, i - startIndex + 1);                path.push_back(str);            &#125; else &#123;                                // 不是回文，跳过                continue;            &#125;            backtracking(s, i + 1); // 寻找i+1为起始位置的子串            path.pop_back(); // 回溯过程，弹出本次已经填在的子串        &#125;    &#125;    bool isPalindrome(const string&amp; s, int start, int end) &#123;        for (int i = start, j = end; i &lt; j; i++, j--) &#123;            if (s[i] != s[j]) &#123;                return false;            &#125;        &#125;        return true;    &#125;public:    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;        result.clear();        path.clear();        backtracking(s, 0);        return result;    &#125;&#125;;","categories":["算法"],"tags":["LeetCode","算法"]},{"title":"LeetCode--766.托普利茨矩阵","url":"/2021/02/22/LeetCode-766-%E6%89%98%E6%99%AE%E5%88%A9%E8%8C%A8%E7%9F%A9%E9%98%B5/","content":"Description给你一个 m x n 的矩阵 matrix 。如果这个矩阵是托普利茨矩阵，返回 true ；否则，返回 false 。\n如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是托普利茨矩阵 。\n\n示例 1：\n\n\n输入：matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]] 输出：true 解释： 在上述矩阵中, 其对角线为:“[9]”, “[5, 5]”, “[1, 1, 1]”, “[2, 2, 2]”, “[3, 3]”, “[4]”。各条对角线上的所有元素均相同, 因此答案是 True 。\n\n\n示例 2：\n输入：matrix = [[1,2],[2,2]] 输出：false 解释： 对角线 “[1, 2]” 上的元素不同。\n\n提示：m &#x3D;&#x3D; matrix.lengthn &#x3D;&#x3D; matrix[i].length1 &lt;&#x3D; m, n &lt;&#x3D; 200 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 99\n进阶：\n如果矩阵存储在磁盘上，并且内存有限，以至于一次最多只能将矩阵的一行加载到内存中，该怎么办？如果矩阵太大，以至于一次只能将不完整的一行加载到内存中，该怎么办？\nSolutionclass Solution &#123;public:    bool isToeplitzMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        bool flag =true;        int m = matrix.size();        int n = matrix[0].size();        if(m == 1 &amp;&amp; n == 1)             return true;        if(m == 1&amp;&amp; n == 0)             return false;        //如果矩阵没有对角线则都是符合要求的        if((m == 1 &amp;&amp; n &gt; 1) || (m &gt; 1 &amp;&amp; n == 1))             return true;                for(int i=1;i&lt;m;i++)&#123;            for(int j=1;j&lt;n;j++)&#123;                if(matrix[i][j] != matrix[i-1][j-1])&#123;                    flag=false;                    break;                &#125;            &#125;        &#125;        return flag;    &#125;&#125;;\n\n","categories":["算法"],"tags":["LeetCode","算法"]},{"title":"LeetCode--832.翻转图像","url":"/2021/02/24/LeetCode-832-%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/","content":"Description给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。\n水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。\n反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。\n\n示例 1:\n输入: [[1,1,0],[1,0,1],[0,0,0]] 输出: [[1,0,0],[0,1,0],[1,1,1]] 解释:首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]\n\n\n示例 2:\n输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] 输出:[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] 解释: 首先翻转每一行:[[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n\n\n说明:\n1 &lt;= A.length = A[0].length &lt;= 200 &lt;= A[i][j] &lt;= 1\n\nSolutionPS：因为是二进制数组，所以反转图像可以直接用异或运算直接反转。\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123;        int length = A.size();        int left = 0, right = 0,mid = length / 2;\t\tfor (int i = 0; i &lt; length; ++i) &#123;\t\t\tleft = 0, right = length - 1;\t\t\twhile(left &lt; right)&#123;\t\t\t\tif(A[i][left] == A[i][right]) &#123;\t\t\t\t\tA[i][left] ^= 1;\t\t\t\t\tA[i][right] ^= 1;\t\t\t\t&#125;\t\t\t\t++left;\t\t\t\t--right;\t\t\t&#125;\t\t\tif (length % 2 == 1) &#123;\t\t\t\tA[i][mid] ^= 1;\t\t\t&#125;\t\t&#125;\t\treturn A;    &#125;  &#125;;","categories":["算法"],"tags":["LeetCode","算法"]},{"title":"LintCode—第一个只出现一次的字符","url":"/2020/10/17/LintCode%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/","content":"题目要求209.第一个只出现一次的字符给出一个字符串，找出第一个只出现一次的字符。\n样例样例 1:    输入: “abaccdeff”    输出:  ‘b’\n解释:\n&#39;b&#39; 是第一个出现一次的字符\n\n样例 2:    输入: “aabccd”    输出:  ‘b’\n解释:\n&#39;b&#39; 是第一个出现一次的字符\n\n解决方案：class Solution &#123;public:    /**     * @param str: str: the given string     * @return: char: the first unique character in a given string     */    char firstUniqChar(string &amp;str) &#123;        // Write your code here        int len = str.size();               for (int i=0;i&lt;len;i++)&#123;            /* code */             int sum = 0;            for(int j=0;j&lt;len;j++)            &#123;                if(str[i]==str[j])                    sum ++;                if(sum&gt;1)                     break;            &#125;            if(sum==1)            &#123;                return str[i];                break;            &#125;        &#125;    &#125;&#125;;\n","categories":["算法"],"tags":["算法","LintCode"]},{"title":"LintCode—两数之和&落单的数","url":"/2020/10/15/LintCode%E2%80%94%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C&%E8%90%BD%E5%8D%95%E7%9A%84%E6%95%B0/","content":"题目要求56. 两数之和给一个整数数组，找到两个数使得他们的和等于一个给定的数 target。\n你需要实现的函数twoSum需要返回这两个数的下标, 并且第一个下标小于第二个下标。注意这里下标的范围是 0 到 n-1。\n样例Example1:给出 numbers = [2, 7, 11, 15], target = 9, 返回 [0, 1].Example2:给出 numbers = [15, 2, 7, 11], target = 9, 返回 [1, 2].挑战给自己加点挑战\nO(n)O(n) 空间复杂度，O(nlogn)O(nlogn) 时间复杂度，O(n)O(n) 空间复杂度，O(n)O(n) 时间复杂度，注意事项你可以假设只有一组答案。\nclass Solution &#123;public:    /**     * @param numbers: An array of Integer     * @param target: target = numbers[index1] + numbers[index2]     * @return: [index1 + 1, index2 + 1] (index1 &lt; index2)     */    vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) &#123;        // write your code here        int i = 0;\t\tint j = 0;\t\tvector&lt;int&gt; a;\t\tfor (i = 0; i &lt; numbers.size(); i++)\t\t&#123;\t\t\tfor (j = i + 1; j &lt; numbers.size(); j++)\t\t\t&#123;\t\t\t\tif ((numbers[i] + numbers[j]) == target)\t\t\t\t&#123;\t\t\t\t\ta.push_back(i);\t\t\t\t\ta.push_back(j);\t\t\t\t\treturn a;\t\t\t\t&#125;\t\t\t\telse\t\t\t\t&#123;\t\t\t\t\tcontinue;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;    &#125;&#125;;\n\n82.落单的数给出 2 * n + 1个数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。\n样例样例 1:\n输入：[1,1,2,2,3,4,4]输出：3解释：仅3出现一次样例 2:\n输入：[0,0,1]输出：1解释：仅1出现一次挑战一次遍历，常数级的额外空间复杂度\n注意事项n≤100\nclass Solution &#123;public:    /**     * @param A: An integer array     * @return: An integer     */    int singleNumber(vector&lt;int&gt; &amp;A) &#123;        // write your code here        int ans = 0;        for(int i=0; i&lt;A.size(); ++i)            ans ^= A[i];        return ans;    &#125;&#125;;\n参与运算的两个值，如果两个相应bit位相同，则结果为0，否则为1。即：0^0 = 0， 1^0 = 1， 0^1 = 1， 1^1 = 0按位异或的3个特点:(1) 0^0=0,0^1=1  0异或任何数＝任何数(2) 1^0=1,1^1=0  1异或任何数－任何数取反(3) 任何数异或自己＝把自己置0思路：通过异或，相同的数结果为0，那么最后的结果一定是落单的数字。\n","categories":["算法"],"tags":["算法","LintCode"]},{"title":"LintCode—字符串查找","url":"/2020/10/16/LintCode%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE/","content":"题目要求13.字符串查找对于一个给定的 source 字符串和一个 target 字符串，你应该在 source 字符串中找出 target 字符串出现的第一个位置(从0开始)。如果不存在，则返回 -1。\n样例 1:输入: source = “source” ， target = “target”输出:-1样例解释: 如果source里没有包含target的内容，返回-1\n样例 2:输入: source = “abcdabcdefg” ，target = “bcd”输出: 1样例解释: 如果source里包含target的内容，返回target在source里第一次出现的位置\n挑战O(n2)的算法是可以接受的。如果你能用O(n)的算法做出来那更加好。（提示：KMP）\n说明在面试中我是否需要实现KMP算法？\n不需要，当这种问题出现在面试中时，面试官很可能只是想要测试一下你的基础应用能力。当然你需要先跟面试官确认清楚要怎么实现这个题。\nclass Solution &#123;public:    /**     * @param source:      * @param target:      * @return: return the index     */    int strStr(string &amp;source, string &amp;target) &#123;        // Write your code here        int i, j;        int lenh = source.length();        int lenn =  target.length();        if (lenn == 0)            return 0;        for (i = 0; i &lt;= lenh - lenn; i++) &#123;            for (j = 0; j &lt; lenn; j++)                 if (source[i + j] !=  target[j])                     break;            // 匹配成功            if (j == lenn)                  return i;        &#125;        return -1;    &#125;&#125;;\n","categories":["算法"],"tags":["算法","LintCode"]},{"title":"Mac os上配置PD虚拟机，使其共享网络访问公网","url":"/2019/10/16/Mac%20os%E4%B8%8A%E9%85%8D%E7%BD%AEPD%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E4%BD%BF%E5%85%B6%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E5%85%AC%E7%BD%91/","content":"Pd(Paralles Desktop)是Mac下非常好用的虚拟机软件，速度非常快。pd之所以比较快，是因为它采用了半虚拟化的方式，\n从网卡类型处可以见一些端倪，下图中的virtio，很强大就对了。\n\n声明：以下描述中，虚拟机指在pd中所安装的虚拟机，如cent os等linux发行版。需求：\n\n给虚拟机配置表态ip，如192.168.6.10/24。\n无论mac是否已经连接外网，在mac上都可直接连接到虚拟机的内网地址。\n当mac连接到外网时，虚拟机也可以连接到外网。\n\n\n安装pd之后，会在mac中增加一个虚拟网卡，这个是pd用于把虚拟机和宿主系统如mac互联的网络接口，相当于虚拟机和宿主系统之间的一个交换机，如下所示。\n\n也可以在终端使用命令行来查看。\n\nvnic0中的vnic是指virtual net interface card，即虚拟网络接口，后面的0对应的是图一左上角虚拟网卡中的#0,即蓝色部分，它表示pd安装的第0块网卡。\n以上两个图中显示的是同一块刚卡，因此ip都是192.168.6.2。这个并不是我在图一中的“ip address”中配置的，它是在pd中配置的。\n可以打开pd的偏好设置里面进行相关设置。\n\n图三中配置的是shared模式，即让我们的虚拟机与mac共享外网，红色框框中的enable ipv4 dhcp是用来打开内置的dhcp服务，熟悉nat模式的同学都知道，这就是让虚拟机通过nat模式上网的方式。下面蓝色框框中的start address等三个输入框是用来确认dhcp的地址池，即虚拟机采用dhcp方式可自动获取的ip地址的范围。\n如果用dhcp获取ip的话，虚拟机中的ip地址就不固定，也许下次开机时就换了个新的ip，那么每次都要去查看下新的ip才能连接到虚拟机。因此我需要把虚拟机设置为固定ip，即静态ip，所以没有勾选enable ipv4 dhcp，也就是说要手动配置ip，需要填写地址池，因为这是在借助nat的方式，虚拟机中所配置的ip地址必须要属于此ip地址范围，而且这不仅是为了配置虚拟机的ip范围，还要给pd在宿主机上的虚拟网卡vnic0分配地址。\n之后，确认一下配置，如图四所示。\n\n将网卡network1（我只配置了一块，具体以大家实际需求为准）的source源选择为Shared Network，也就是将虚拟机的网卡绑定到此Shared Network，Shared Network就是上面图四中的连接方式Shared，这样虚拟机便可与mac共享网络。\n还没完，还需要配置虚拟机的ip。\n启动虚拟机后，进入网卡文件的配置目录，用vim编辑网卡配置文件,我这里的网卡配置文件是ifcfg-eth0,具体以大家实际的为主。如图五所示。\n使用的命令是 \nvi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0\n\n\n图中的bootproto采用的是static，表示静态，也可以写成none，大小写均可。接下来的是手动配置的ip，主要注意的是GATEWAY网关，这里配置的是192.168.6.1，并不是图一或图二中的192.168.6.2，因为我们并不是把mac当成Ip数据报文转发路由器（如同vmware中使用仅主机模式共享网络，然后虚拟机把网关指向vmware所共享的网卡ip），而是当成nat路由器，当采用nat方式为虚拟机提供网络服务时，pd会单独为虚拟机生成一个网关地址，这通常是地址池中的第1个ip,如图三中的起始地址，而图二中vnic0的地址是地址池中的第2个ip，即192.168.6.2。\n编辑完文件后，重启网络，我的虚拟机是centOs6.3，执行的命令是 service network restart\n\n如图六所显示，配置成功。\n我们在网卡配置文件中已经设置好了GATEWAY是192.168.6.1，这是虚拟机上网的关键，可以用ip r命令验证一下路由表，如图七所示。\n\n如果mac的外网是通的，现在可以在虚拟机中用ping命令测试下网络了，如图八所示，网是通的。\nping自己的mac主机也可以，如图九所示。\n\n接下来在mac上直接访问虚拟机试试看，这里用ssh连接虚拟机的ip地址192.168.6.10,如图十所示，通了。\n\n自此便实现了mac通过内网连接虚拟机，虚拟机又可以通公（外）网。\n","categories":["实验"],"tags":["Linux","虚拟机"]},{"title":"Mac配置Python环境","url":"/2019/10/16/Mac%E9%85%8D%E7%BD%AEPython%E7%8E%AF%E5%A2%83/","content":"@TOC\n一.python简介\nPython是用来编写应用程序的高级编程语言。Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。\n\nPython适合的开发项目：\n\n网络应用，包括网站、后台服务等等；许多日常需要的小工具，包括系统管理员需要的脚本任务等等；另外就是把其他语言开发的程序再包装起来，方便使用。\n\n当然，python也有缺点：\n\npython和C程序相比非常慢。因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。\n\n二.Mac下配置python开发环境\nMac OS X系统自带python，可以在终端输入python查看版本【输入exit()即可退出】，如下：当然，可以看出，系统自带的python2.7版本已经不推荐使用了，通俗一点说，也就是绝版了。\n\nPython安装方法：\n\n\n\nMac OS下安装Python主要方式有两种：\nHomebrew安装\n\n\nHomebrewPS：（当然，这种方法是之前在电脑上安装过Xcode的命令行工具，如果之前没有安装过的话，可以打开终端输入指令“xcode-select –install”安装，之后就直接同意就可以）安装套件管理工具-Homebrew\n\nHomebrew官网获取安装指令，官网地址：https://brew.sh/安装指令：/usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;\n\n终端安装Homebrew（1）打开终端-&gt;输入步骤1中的安装指令（2）点击return-&gt;输入密码（输入密码后控制台不会显示，mac的安全机制，输入按回车即可）（3）验证安装成功输入指令：brew doctor ，显示 Your system is ready to brew\n\n安装python3终端指令安装，安装指令：brew install python3\n\n\n验证安装成功终端输入指令：python3，显示下图信息即安装成功\n\n\n\n\n官网下载安装\n\n\n访问Python官网（https://www.python.org/downloads,下载安装Python安装包，一路点击安装即可。\n\n验证安装是否成功终端输入以下命令，查看Python安装位置which python终端输入以下命令，查看Python当前版本python --version终端输入以下命令，进入Python交互模式python\n\n\n三.Python集成开发环境PycharmPyCharm是由JetBrains打造的一款Python IDE，十分好用，好用的不打鸟，强烈推荐。\n当然，专业版软件是需要收费的，没有钱但有能力的可以试试找找相应的办法，我是在淘宝上买了个激活码，也不是很贵。\n当然，话又说回来了，如果有能力，还是希望能够支持正版。Pycharm下载官网\n根据自己需要的版本进行相关的下载：最后，成功激活后的样子：\n\n","categories":["Python"],"tags":["Python","环境配置"]},{"title":"leetcode--704.二分查找","url":"/2021/11/13/leetcode--704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","content":"好久没有刷算法题了，感觉自己得重头来了！\n从二分查找开始复习了。\nDescription给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n\n示例 1:\n输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4\n\n\n示例 2:\n输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1\n\n\n提示：\n你可以假设 nums 中的所有元素是不重复的。n 将在 [1, 10000]之间。nums 的每个元素都将在 [-9999, 9999]之间。\n\nSolution 二分查找主要需要定义一个边界和中间的概念。\n在这里，我们可以定义左边界为left，右边界为right，中间界为middle。\n其中，right = nums.length，也就是数组的长度；middle = （right-left）+ left，也就是代表着中界值，重要的是一定要加上left，因为随着数组范围的变化，最后要取的是变化范围的ß中间值，不单是简单的中界值。\n接下来，只要进行判断就行：\n如果target = nums[middle]，那么返回target。\n如果target &gt; nums[middle]，那么left = middle + 1；\n如果target &lt; nums[middle]，那么right = middle - 1；\n如果都没有，最后返回-1。\n代码如下：\nvar search = function(nums, target) &#123;​    let left = 0;​    let right = nums.length - 1;​    while(left &lt;= right)&#123;​        const middle = Math.floor((right-left)/2) + left;​        const num = nums[middle];​        if(target === num)&#123;​            return middle;​        &#125;else if(target &gt; num)&#123;​            left = middle + 1;​        &#125;else&#123;​            right = middle -1;​        &#125;​    &#125;​    return -1;&#125;;\n\n\n","categories":["算法"],"tags":["LeetCode","算法"]},{"title":"实验项目一：Linux的安装","url":"/2020/03/20/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E4%B8%80%EF%BC%9ALinux%E7%9A%84%E5%AE%89%E8%A3%85/","content":"1. 实验目的与原理：熟练虚拟机安装。\n2. 实验内容与步骤：\n检查Windows安装环境。\n安装虚拟机文件。\n虚拟机安装，在虚拟机中安装Linux系统。3. 主要仪器及耗材：笔记本电脑。\n\n4. 教学方式：案例教学法。\n预习要求：预习Linux命令的相关知识点。\n要求：认真编写，认真截图。\n实验步骤：\n安装文件:根据老师的分享将所需要的文件下载，如图所示。\n\n当然，也可以根据自己需要的版本到官网上进行下载。\nCent OS官网.2. 安装虚拟机：\n因为我使用的是Mac系统，而且之前已经安装过虚拟机了，所以，就使用了Parallels Desktop，其作用都是一致的。\n图为已安装好的虚拟机以及其控制中心：\n\n安装Linux系统：\n\n（1）打开虚拟机：\n（2）选择需要安装的系统镜像：\n（3）进行安装系统的相关虚拟机配置： 用户名root以及密码123456，位置与名称，相关磁盘分配：   \n（4）进入Linux系统的安装：安装系统文件：\n\n直接Install or upgrade an existing system即可。\n如果出现了以下界面，可以直接进行CD/DVD的配置，将所需要的镜像文件导入即可：\n\n\n导入成功：\n\n（5）配置Linux系统基本信息：选择语言输入法以及时区等基本设置。\n设置根用户的密码123456：\n\n配置Linux的自定义分区，配置主分区以及逻辑分区：\n\n\n\n格式化，写入数据：\n\n配置Linux系统场景：选择的是Basic Server，如图所示：\n\n等待系统安装：\n\n\n\n登录安装后的系统root登录：\n\n输入用户名root以及密码123456，可以看到已经成功登陆了：\n\n虚拟机上也多了一个系统：\n\n","categories":["实验"],"tags":["Linux","大数据","实验"]},{"title":"实验项目一：免秘钥登录","url":"/2020/04/08/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E4%B8%80%EF%BC%9A%E5%85%8D%E7%A7%98%E9%92%A5%E7%99%BB%E5%BD%95/","content":"\n实验内容与步骤1. 关闭防火墙查看防火墙状态：\nservice iptables status\n关闭防火墙：\nchkconfig iptables offorservice iptables stop\n\n2. 时间同步date命令查看时间是否同步：\n可见，时间已经同步，如果不同步的话，可以采取以下命令进行同步。\nyum -y install ntp ntpdate ntpdate cn.pool.ntp.org\n3. 测试两台电脑互相访问可以互相访问，但此时还需要秘钥来登录：\n4. 创建密钥对用ssh-keygen -t rsa -P ‘’ 来创建密钥对\n5. 发送公钥scp id_rsa.pub slaver20:~或scp id_rsa.pub master10:~将公钥发送到对方电脑上：\n6. 把公钥填到信任列表在另一台电脑上将公钥移至.ssh文件夹中（将其放入authorized_keys文件中）：cat id_rsa.pub &gt;&gt; .ssh/authorized_keys：可以看到，master的公钥是slaver的，slaver的公钥是master的。\n7. 两台主从服务器互通免秘钥配置最后进行测试：如图可见，实现了免秘钥登录。\n","categories":["实验"],"tags":["大数据","实验"]},{"title":"实验项目三：Linux命令权限管理及搜索","url":"/2020/03/30/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E4%B8%89%EF%BC%9ALinux%E5%91%BD%E4%BB%A4%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%8F%8A%E6%90%9C%E7%B4%A2/","content":"\n实验步骤以及截图：1. 使用cp命令从root目录下拷贝一个文件install.log到/ tmp/happylinux。\n首先，查看tmp目录下的happylinux目录下是否有文件，经确认，没有文件。\n然后，用cd命令切换到root目录下，用cp命令将所需要的文件复制过去。\n最后，查看tmp目录下的happylinux目录下是否存在想要复制的文件，的确存在，复制完成。\n\n\n2.    使用chmod命令分别给用户所有者和所属组添加w权限。\n给用户所有者加w权限：\n给用户所属组加w权限：\n\n\n3.    使用chmod的命令用764数字代表权限位修改ugo权限并查看修改结果。\n4.    使用useradd命令创建新用户dingjun 并能够和root用户自由切换登录。创建新用户：useradd 新用户名切换用户： su 用户名\n5.    使用 find命令根据文件的名字包含“ins”模糊查找/根目录所有文件。find模糊查找的命令：find  [查找目录名]  -name  [描述]\n6．使用shutdown命令关闭系统。立刻关闭系统：\n\n","categories":["实验"],"tags":["Linux","大数据","实验"]},{"title":"实验项目三：java api访问hdfs","url":"/2020/04/14/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E4%B8%89%EF%BC%9Ajava%20api%E8%AE%BF%E9%97%AEhdfs/","content":"实验内容与步骤1. 从linux拷贝整个hadoop压缩jar包使用ForkLift将hadoop文件全部拷出来。将需要用到的jar包放在一起。（需要的是share/hadoop/common下的三个包，share/hadoop/common/lib文件下全部的包，以及share/hadoop/hdfs下的三个包，以及share/hadoop/hdfs/lib中的包）\n2. 从linux拷出配置文件可以访问hdfs将core-site.xml和hdfs-site.xml``log4j.properties文件拷出来：core-site.xml文件需要更改一下：将黄线的部分改成自己的IP，然后再加上后面的配置就可以。\n3. 使用java开发工具编写java代码简单的配置idea：将第二步导出的文件放到src内，第一步导出的hadoop文件夹直接add as library简单测试一下：可以看到，在hadoop上成功创建了文件夹。\n4. 使用Configuration 类，Path，FileSystem对象完成上传代码\n5. 上传文件测试50070测试成功上传文件。\n6. 使用Configuration 类，Path，FileSystem对象完成下载代码\n7. 查看下载文件是否存在可以看到文件也成功下载了。以下为本次的实验代码：\npackage com.itshixun.hdfs;import java.io.IOException;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.FileStatus;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;class DownLoad &#123;    public static void main(String[] args) &#123;        uploadFile();        downloadFile();    &#125;    public static void uploadFile() &#123;        Configuration conf = new Configuration();        try &#123;            FileSystem fs = FileSystem.get(conf);            //定义文件的路径和上传的路径            Path src = new Path(&quot;/Users/sunyumeng/readme.txt&quot;);            Path dest = new Path(&quot;/ss/README.txt&quot;);            //从本地上传文件到服务器            fs.copyFromLocalFile(src, dest);        &#125; catch (IOException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125;    &#125;    public static void downloadFile() &#123;        Configuration conf = new Configuration();        try &#123;            FileSystem fs = FileSystem.get(conf);            //定义下载文件的路径和本地下载路径            Path src = new Path(&quot;/ss/README.txt&quot;);            Path dest = new Path(&quot;/Users/sunyumeng/READMEtest.txt&quot;);            //从服务器下载文件到本地            fs.copyToLocalFile(src, dest);        &#125; catch (IOException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125;    &#125;&#125;","categories":["实验"],"tags":["Linux","大数据","实验"]},{"title":"实验项目二：Linux的happylinux目录文件操作","url":"/2020/03/25/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E4%BA%8C%EF%BC%9ALinux%E7%9A%84happylinux%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","content":"\n实验步骤：1. root账号登录到终端，使用pwd命令查看当前目录。\nLinux下 pwd命令用于显示工作目录。\n2.用cd命令将当前目录切换到“/”下：cd命令命令格式：cd &lt;路径&gt;意义：cd是change directory 的缩写；cd命令后面跟一个路径，用于切换当前用户所在的路径，其中路径可以是绝对路径也可以是相对路径。\n\n3.使用ls命令查看linux的目录结构，并能查看隐藏文件和文件类型大小。命令格式：ls &lt;参数&gt; &lt;路径&gt;意义：ls是list的缩写；ls命令后面可以跟一个路径或参数，也可以不跟，表示列出路径或当前目录下的所有文件信息。最常用的的参数是“-l”，也就是“ls -l”命令。ls / 显示根目录下的所有文件及文件夹。ls -l / 显示/路径下的所有文件及文件夹的详细信息。ls -l 显示当前路径下的所有文件及文件夹的详细信息。ls –a  目前该目录下的所有文件及文件夹（包括隐藏文件）ls –all 显示了目前该目录下的所有文件及文件夹（包括隐藏文件），而且还显示了每一个文件及文件夹的属性、所有者、创建时间、大小等等信息。\n\n\n4. 创建happylinux目录在/tmp目录下。首先切换到/tmp目录下，然后用mkdir命令创建新目录。\n5.用一条命令使用cp命令将root目录下三个文件拷贝到tmp目录下的happylinux目录下。首先，查看tmp目录下的happylinux目录下是否有文件，经确认，没有文件。然后，用cd命令切换到root目录下，用cp命令将所需要的文件复制过去。最后，查看tmp目录下的happylinux目录下是否存在想要复制的文件，的确存在，复制完成。\n\n6.使用cat命令查看happylinux下install.org文件内容并加入行号显示。\n7.使用less命令查看install.log并搜索关键字i686并查看下一个匹配项并退出。\n输入/i686 查找关键字，字母键n可以查看下一个匹配项，字母q退出。\n\n8.并对root目录下的anaconda-ks.cfg查看文件信息并人性化查看文件大小显示大小为1.2kb。cd切换回到root目录下，人性化查看 -lh\n\n9.更改happylinux目录名称为linuxhappy。\n10.删除所有linuxhappy目录下所有文件并没有任何提示信息。\n如果连同linuxhappy目录一同删除\n\n\n如果仅删除目录下的文件，但保留目录可以切换到linuxhappy目录下，直接用rm -rf *\n\n\n11.查看下目录位置（路径）。查看linuxhappy文件的位置：\n\n12.使用命令现在关闭linux系统。\n\n成功关闭系统。\n","categories":["实验"],"tags":["Linux","大数据","实验"]},{"title":"实验项目二：伪分布式环境搭建","url":"/2020/04/10/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E4%BA%8C%EF%BC%9A%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","content":"\n实验内容与步骤1. 配置hadoop下的etc/hadoop/core-site.xml切换到etc/hadoop目录下，对core-site.xml进行编辑\nvi core-site.xml\n进行以下的配置：\n2. 配置 hdfs-site.xmlvi hdfs-site.xml\n3. 格式hdfshdfs namenode -format\n4. 启动hadoop namenode(调用sbin里的命令)start-dfs.sh \n5. Jps 命令 发现没有namenode节点解决办法：本机没有对自己免密码  pub写入 authorized文件里即可\n[root@masternode1 ~]# cd .ssh[root@masternode1 .ssh]# lsauthorized_keys  id_rsa  id_rsa.pub  known_hosts[root@masternode1 .ssh]# cat id_rsaid_rsa      id_rsa.pub  [root@masternode1 .ssh]# cat id_rsa.pub &gt;&gt; authorized_keys \n\n6. ssh 本机IP地址测试不用密码\n7. 格式化hdfs namenode -format\n8. 查看结果地址http://10.211.55.10:50070/访问成功，此时已有namenode结点。\n","categories":["实验"],"tags":["Linux","大数据","实验"]},{"title":"实验项目五：备份和恢复","url":"/2020/04/05/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E4%BA%94%EF%BC%9A%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/","content":"\n实验内容与步骤1. 确认系统是否有yum云的dump抓包工具，原因dump默认6.3版本没有安装。默认版本没有安装，输入命令 yum -y install dump.i686 进行安装\n\n2. 确认好了可以yum安装了。\n3. 如果要备份分区 、如何查看，之前课程shell已经学过命令。\n4. 进行备份boot分区所有文件并把它保存到/tmp/目录下。输入命令：dump -0uj -f /tmp/boot.bak.bz1 /boot查看tmp目录下是否存在备份：可以看到，该目录下已经存在文件了。\n5. 查看备份成功后的信息。/boot 有过0级备份。\n6. 拷贝一个文件到boot目下我们做下增量备份。将install.log复制到/boot下并改名为hhhinstall.log，查看是否备份成功。\n7. 我们做第一次增量备份代码。/boot 有过一次1级备份。\n\n8. 查看增量备份的大小很小的速度也很快。增量备份比完全备份小，很明显。\n\n9. 查看分区的备份等级及记录。\n10. 还原数据。\n","categories":["实验"],"tags":["Linux","大数据","实验"]},{"title":"实验项目四：shell编程添加用户和密码","url":"/2020/04/02/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E5%9B%9B%EF%BC%9Ashell%E7%BC%96%E7%A8%8B%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%92%8C%E5%AF%86%E7%A0%81/","content":"\n实验内容与步骤1. 使用for循环批量添加linux用户。首先，创建文件，然后为文件授权，最后运行文件。首先输入需要添加用户的总数量，然后进入for循环，添加用户。\n\n也可以将输出的信息添加到user.txt文件。\n\n2.名字，数量，密码不能为空if判断。y=$(echo $num | sed ‘s/[0-9]//g’)这句将num中素有数字替换成空字符串的代码也可以用以下正则的表达式书写\ny=$(echo $num | sed ‘s/^[0-9]*$//g’)它的意思是如果num是以数字开头和数字结尾的一个纯数字，那么替换成空字符串，否则不做替换\necho $pass | passwd –stdin $name$i这句表示给用户赋予新的密码\n\n\n以上是自己输入用户，自己进行添加下面是添加类似stu1，stu2。。。类似的用户：\n#!&#x2F;bin&#x2F;bashread -t 30 -p &quot;input name:&quot; nameread -t 30 -p &quot;input num:&quot; numread -t 30 -p &quot;input password:&quot; pass if [ ! -z &quot;$name&quot; -a ! -z &quot;$num&quot; -a ! -z &quot;$pass&quot;  ]\tthen\t\ty&#x3D;$(echo $num | sed &#39;s&#x2F;[0-9]&#x2F;&#x2F;g&#39;)\t\tif [ -z &quot;$y&quot;  ]\t\t\tthen\t\t\t\tfor (( i&#x3D;1;i&lt;&#x3D;$num;i&#x3D;i+1 ))\t\t\t\t\tdo\t\t\t\t\t\tuseradd $name$i &amp;&gt;&#x2F;dev&#x2F;null\t\t\t\t\t\techo $pass | passwd --stdin $name$i &amp;&gt;&#x2F;dev&#x2F;null  \t\t\t\t\t\tdone\t\tfifi\n\n\n3.熟练使用sed命令判断num的数字类型命令。采用if循环，通过sed来判断输入的num变量是否为整数，并在屏幕上进行相应的反馈。\n\n4.使用管道操作条件。  管道就是一个进程与另一个进程之间通信的通道，它通常是用作把一个进程的输出通过管道连接到另一个进程的输入。它是半双工运作的，想要同时双向传输需要使用两个管道。管道又可以分为匿名管道和命名管道，shell中使用到的是匿名管道。  管道的本质是内存中的缓冲区，可以看作是打开到内存中的文件。所以需要使用两个文件描述符来索引它，一个表示读端，一个表示写端。并且规定，数据只能从读端读取、只能往写端写入。  \n管道的局限性：\n① 数据自己读不能自己写。\n② 数据一旦被读走，便不在管道中存在，不可反复读取。\n③ 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。\n④ 只能在有公共祖先的进程间使用管道。\n管道命令的操作符是：”|”，它只能处理由前面一条指令传出的正确输出信息，对错误信息是没有直接处理能力的。然后，传递给下一条指令，作为操作对象。\n基本格式： 指令1 | 指令2 | …\n【指令1】正确输出，作为【指令2】的输入，然后【指令2】的输出作为【指令3】的输入，如果【指令3】有输出，那么输出就会直接显示在屏幕上面了。通过管道之后【指令1】和【指令2】的正确输出是不显示在屏幕上面的。\n\n【提醒注意】：\n管道命令只能处理前一条指令的正确输出，不能处理错误输出；管道命令的后一条指令，必须能够接收标准输入流命令才能执行。\n","categories":["实验"],"tags":["Linux","大数据","实验"]},{"title":"实验项目四：完全分布式搭建","url":"/2020/04/17/%E5%AE%9E%E9%AA%8C%E9%A1%B9%E7%9B%AE%E5%9B%9B%EF%BC%9A%E5%AE%8C%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA/","content":"实验内容与步骤1. 配置网络环境：本次实验用的是Cent OS 6.5 minimal版本，相应的版本可以在官网上下载。首先安装：我是用的是parallels desktop 来安装，安装步骤详见：链接: Mac os上配置PD虚拟机，使其共享网络访问公网.\nvi /etc/sysconfig/network-scripts/ifcfg-eth0进行网络环境的相关配置：设置DNS解析（不同的系统不一样）：vi /etc/resolv.confservice network restart命令，重启网络服务。测试网络：ping自己和外网都能通，网络配置成功。\n2. 时间同步ntp：yum -y install ntp ntpdate ntpdate cn.pool.ntp.org\n 以上命令进行时间的同步： date查看当前时间\n3. 克隆系统：前两步做好了之后，可以关机，然后将系统进行克隆，因为需要配置Hadoop的完全分布式搭建，所以克隆了两个主机。\n主机克隆后，需要将网络环境重新配置一下，将硬件地址和UUID删除，并将IP地址更换，之后删除Linux物理地址绑定的文件（该文件会在操作系统重启并生成物理地址以后将物理地址绑定到IP上）rm -rf /etc/udev/rules.d/70-persistent-net.rules\n当然，也可以更改一下主机名称：vi /etc/sysconfig/network将HOSTNAME=后面的内容更改成需要的名称即可。\n修改网络映射hostsvim /etc/hosts\n例子：192.168.100.132 master192.168.100.133 slave1192.168.100.134 slave2\n最后需要重启一下系统：shutdown -r now 或者init 6 \n最后的效果：\n\n4. 免秘钥操作：\n生成密钥ssh-keygen -t rsa # 一路回车\n\n将集群中的所有公钥集中到某台机器，生成免密授权登录文件bigdata22:\nscp ~/.ssh/id_rsa.pub bigdata11:/root/.ssh/22\n\nbigdata33:\nscp ~/.ssh/id_rsa.pub bigdata11:/root/.ssh/33\nbigdata11:切换到根目录下的.ssh文件中：\ncat id_rsa.pub &gt;&gt; authorized_keyscat 22 &gt;&gt; authorized_keyscat 33 &gt;&gt; authorized_keys\n对文件进行授权：chmod 600 authorized_keys必须改，不然不能免密登录\n\n将授权列表分发给bigdata22和bigdata33:\nscp ~/.ssh/authorized_keys bigdata22:/root/.ssh/authorized_keysscp ~/.ssh/authorized_keys bigdata33:/root/.ssh/authorized_keys\n\n5. Jdk和Hadoop安装配置：利用ForkLift将所需要的jdk文件以及Hadoop文件拷到三个主机上：可以先配好一台机器中的配置文件，再将软件复制到其他机器，减少配置的工作量。\n\n\nrpm -ivh 命令安装rpm包，安装默认路径：配置环境变量:vi   .bash_profile\n需要source .bash_profile加载一下。测试环境JDK：HADOOP 安装配置：\n\n安装源码包用tar -zxvfCd  /opt/software     tar  -zxvf hadoop-2.5.1_x64.tar.gz \n配置环境变量Vi /root/.bash_profileexport PATHexport JAVA_HOME=/usr/java/jdk1.7.0_79export HADOOP_HOME=/opt/software/hadoop-2.5.1export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin\n\n加载环境变量Source  /root/.bash_profile  \n\n\n6. core-site.xml，hdfs-site.xml，mapred-site.xml，yarn-site.xml配置:\nhadoop-env.sh 和 yarn-env.sh 中将Java的环境变量添加：\n\ncore-site.xml配置：\n\n\n代码片段：\n&lt;property&gt;    &lt;name&gt;fs.defaultFS&lt;/name&gt;    &lt;value&gt;hdfs://master:9000&lt;/value&gt;    &lt;description&gt;默认的文件系统&lt;/description&gt;&lt;/property&gt;&lt;!-- 8020 9000 都是HDFS的RPC端口，都可以 --&gt;&lt;property&gt;    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;    &lt;value&gt;/hadoop/hadoop-2.6.5/data&lt;/value&gt;    &lt;description&gt;&lt;/description&gt;&lt;/property&gt;\n\nhdfs-site.xml配置：\n\n代码片段：\n&lt;property&gt;    &lt;name&gt;dfs.replication&lt;/name&gt;    &lt;value&gt;2&lt;/value&gt;    &lt;description&gt;数据块备份数&lt;/description&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;dfs.permissions.enabled&lt;/name&gt;    &lt;value&gt;false&lt;/value&gt;    &lt;description&gt;关闭权限检查&lt;/description&gt;&lt;/property&gt;\n\nmapred-site.xml配置：\n\n代码片段：\n&lt;property&gt;    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;    &lt;value&gt;yarn&lt;/value&gt;    &lt;description&gt;指定运行mapreduce的框架&lt;/description&gt;&lt;/property&gt;\n\nyarn-site.xml配置：代码片段：\n&lt;property&gt;    &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;    &lt;value&gt;master&lt;/value&gt;    &lt;description&gt;指定namenode节点的地址&lt;/description&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;    &lt;description&gt;NodeManager上运行的附属服务&lt;/description&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;yarn.nodemanager.aux-services.mapreduce_shuffle.class&lt;/name&gt;    &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;    &lt;description&gt;指定shuffle类&lt;/description&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;    &lt;value&gt;true&lt;/value&gt;    &lt;description&gt;是否启用日志聚合，将slave节点的日志聚合至master&lt;/description&gt;&lt;/property&gt;\n将配置好的文件包分别发至其余两个主机上：scp -r /opt/software/hadoop-2.5.1 bigdata22:/opt/softwarescp -r /opt/software/hadoop-2.5.1 bigdata33:/opt/software\n\n更改bigdata11上的slaves文件：\n\n\n\n7. 格式化启动节点:启动hadoophadoop namenode -format\n启动hdfsstart-dfs.sh\n启动yarnstart-yarn.sh查看一下状态：\n\n8. web访问测试:\nHDFS的web端: http://master:50070\nMapReduce的web端: http://master:8088\n\n成功访问，环境搭建完成。\n","categories":["实验"],"tags":["Linux","实验","数据"]},{"title":"汇编实验三 编程·编译·链接·跟踪","url":"/2019/03/07/%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C%E4%B8%89%20%E7%BC%96%E7%A8%8B%C2%B7%E7%BC%96%E8%AF%91%C2%B7%E9%93%BE%E6%8E%A5%C2%B7%E8%B7%9F%E8%B8%AA/","content":"1.  练习内容：练习一：\n编写汇编源程序t1.asm, 源程序代码如图1-1所示。\n\n经过一系列的编写啊，调试啊等等，截图如下：\n\n\n\n 发现有两个输出，为3和6。\n\n练习2: 将 line4和line9种寄存器dl 的值分别修改为 0~9 中任何一个数字，重新汇编→ 连接→运行，观察结果的变化。将line 4 dl的值改为7，将line 9 dl的值改为4。因为截图有的重复，就不一一截取了。\n练习3：用debug对生成的可执行文件 t1.exe 进行调试。\n\n① 使用 r 命令查看。观察寄存器 cx 的值是 多少；观察寄存器 ds 和 cs 的值是多 少，它们之间是否满足关系(cs)=(ds)+10H? \n② PSP（程序段前缀）的头两个字节是CD 20, 用debug查看PSP的内容，验证是否 如此。\n③ 使用 u 命令对 t1.exe 进行反汇编，观察反汇编得到的源代码。\n④ 使用 t 命令和 p 命令（遇到 int 命令时，用 p 命令）单步调试，观察结果。 \n\n\n\n\n改变：输出变成7和4。\n①如图可知：CX的值为0016，DS的值为075A，CS的值为076A，两者间关系满足(cs)=(ds)+10H。\n\n\n  ②③④：用t或p命令逐条执行，每次执行p命令后都有输出值。\n练习二：\n第1步，编写汇编源程序t2.asm，源程序代码如图所示。line6-7 相当于 mov [0], 0433hline9-10 相当于 mov [2], 0436h 至于为什么这样使用两条指令，而不直接简化写成上面的形式，有两个原因。其中一个是方便以后循环;另一个原因，留待第 5 章再解释说明。暂时，先这样使用。\n\n\n第 2 步，对源程序 t2.asm 进行汇编、连接、运行、调试(1). 对 t2.asm 进行汇编、连接后，得到可执行文件 t2.exe。运行 t2.exe，观察程序运行结果，验证是否在屏幕左上方出现红色的数值 36。注*)经测试，有些平台在 dosbox 下运行这个程序时有些问题，如果屏幕左上方没有输出结果，请运行程序 t2.exe 前，先输入 cls 命令清空一下屏幕，然后再执行 t2.exe。(2). 如果(1)结果得到验证，重新打开t2.asm，尝试将源代码中line7的0433h→0432h, line10 的 0436h→0439h, 然后重新汇编、连接，得到可执行文件 t2.exe。使用 cls 命令清屏后，再次观察程序运行结果。(3).  如果(1)结果得到验证，重新打开 t2.asm，尝试将源代码中 line7 的 0433h→0333h, line10 的 0436h→0336h, 然后重新汇编、连接，得到可执行文件 t2.exe。使用 cls 命令清 屏后，再次观察程序运行结果。\n\n\n \n\n\n\n\n\nemmm,可以看出来，随着指令代码的改变，相应的输出也发生了改变。\n\n延伸思考和分析(1)把练习 2 和实验 1「实验任务(4)」，放到一起看，观察并思考这两个实验任务之间 的关联，结合实验 1「实验任务(4)」以及练习 2 中每行汇编指令的功能，理解练习 2 中程 序 t2.asm 实现的功能;(2)把练习 2 和练习 1 放到一起看，结合两个程序各自的源代码以及运行结果，观察 并思考这两个程序在实现数值显示时不同的做法。 \n\n思考：（1）在程序t2.exe中，常数值中bh中存放的数据控制着输出的颜色，bl中存放的数据控制着输出的值。\n（2）   练习一和练习二输出的形式不同：一是用命令形式输出，二是在debug环境下用g命令显示器输出。\n\n\n\ncommand，debug，t1.exe之间是什么关系？command调用debug，debug调用t1；t1结束时返回到debug，debug结束时返回到command；command调用debug，debug调用t1；t1结束时返回到debug，debug结束时返回到command；\n\ndebug调试常用的命令?t–执行当前命令，cs:ip指向下一条指令t–执行当前命令，cs:ip指向下一条指令当遇到int 21指令时，用p执行，返回到debug当debug使用完毕要退出回到command，使用q\n\n\n\n PSP的作用是什么？DOS用来和程序进行通信，t1.exe在操作系统上编写并运行汇编程序的，操作系统管理着内存，它也管理着编译链接生成的汇编程序DOS用来和程序进行通信，t1.exe在操作系统上编写并运行汇编程序的，操作系统管理着内存，它也管理着编译链接生成的汇编程序\n\n","categories":["汇编语言"],"tags":["实验","汇编语言"]},{"title":"汇编实验九 根据材料编程","url":"/2019/04/01/%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C%E4%B9%9D%20%E6%A0%B9%E6%8D%AE%E6%9D%90%E6%96%99%E7%BC%96%E7%A8%8B/","content":"写在前面的提示：\n特别说明：本次实验中所需的 80×25 彩色字符模式只有在全屏 dos 下才能看到效果。(在 dosbox 下， 有些系统中会出现屏幕上彩色块显示不稳定的状况)故，请使用「Masm for Windows 集成实验环境共享版」完成此程序编写及效果查看。 启动「Masm for Windows 集成实验环境共享版」后，按要求设置其兼容模式:\n\n提示编程实现需要考虑的点:\n\n屏幕中间对应的显存位置要计算好\n\n绿色、绿底红色、白底蓝色的字符串——每个字符及属性的信息可以提前定义好在数据 段中，然后向相应的显存复制(其实就是 mov)。附:本题中显示字符串所对应的显存空间偏移地址。80×25 的彩色字符模式，共计 25 行:0~24 行 每一行 160 个字节(十六进制 A0H) 中间的位置在 line11, 12, 13。\n\n\n关联引导练习1.在 debug 里参考图 1，使用 e 命令直接向显存 B800:0000 开始的 8 个字节写入 ABCD,属性值绿色。观察效果。 2.在 debug 里参考图 2，使用 e 命令直接向显存 B800:06e0 开始的 8 个字节写入 ABCD， 属性值绿底红色，观察效果。\n\n\n\n这两个练习都是使用 e 命令直接向相应的显存缓冲区写入字符及属性值。由练习直观可见，说明: 只要将字符及属性值正确地写入显示所对应的缓冲区。即可实现字符串的显示。3. 在「Masm for Windows 集成实验环境共享版」中，输入下面的源程序:\n 说明：这道练习是在源程序中，将要显示的字符及属性值写入相应的显存缓冲区，从而达到显示的。请结合提示及 ex9.asm 给出的程序框架及注释提示，动手尝试完成此次实验。\n实验内容\n补全程序 t1.asm，完成在屏幕上输出内存单元中的十进制两位数。程序代码截图：\n\n运行后的截图：成功输出~\n\n补全程序 t2.asm，完成在屏幕上输出 data 段定义的 5 个十进制两位数，数据和数据 之间以空格间隔。程序代码截图：\n\n\n\n\n成功输出~在掌握了任务一的技能后，任务二就很好做了，只需要加入loop循环即可。\n\n教材实验 9(P187)：显示绿色、红底绿色、白底蓝色的welcome to masm!\n\n\n\n程序运行结果：\n实验任务一，二，三难度循序渐进，自己动手尝试乐趣很大，但是也遇到了一些错误，幸运的是，都找到了并且改正了回来。\n","categories":["汇编语言"],"tags":["实验","汇编语言"]},{"title":"汇编实验二 用机器指令和汇编指令编程","url":"/2019/03/05/%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E7%94%A8%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%92%8C%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A8%8B/","content":"实验任务（1）使用Debug，将下面的程序段写入内存，逐条执行，根据指令执行后的实际运行情况填空。书上实验内容：mov ax,ffffmov ds,ax mov ax,2200mov ss,ax mov sp,0100mov ax,[0]             ;ax&#x3D; C0EA;add ax,[2]             ;ax&#x3D; C0FC;mov bx,[4]             ;bx&#x3D; 30F0;add bx,[6]             ;bx&#x3D; 6021; push ax                ;sp&#x3D; 00FE;修改的内存单元的地址是220FE,内容是C0FCpush bx                ;sp&#x3D; 00FC;修改的内存单元的地址是220FC,内容是6021pop ax                 ;sp&#x3D; 00FE;ax&#x3D; 6021pop bx                 ;sp&#x3D; 0100;bx&#x3D; C0FC push [4]               ;sp&#x3D; 00FE;修改的内存单元的地址是220FE,内容是30F0push [6]               ;sp&#x3D; 00FC;修改的内存单元的地址是220FC,内容是2F31\n运行结果：\n\n程序分析：\n首先，我使用的是Mac 系统下 DOSBox 的debug 环境。 \n 不同的系统运行结果是不是一样呢？有可能吧～ 主要考虑他的原理。\n\n逐步分析：首先，前两行代码将ds指向了FFFF段内存，也就是数据段是ffffH：00开始的内存单元了。然后，建立一个栈结构，ss指向2200H段的内存，初始化栈顶指针是100H，ss:sp指向栈底后面第一个单元（目前栈结构是空）；也就是说这个栈结构栈底后面第一个单元地址是2200:100H（物理地址：22100H）\n\n\nmov ax,[0]        &#x2F;&#x2F;ax&#x3D;C0EA;add ax,[2]        &#x2F;&#x2F;ax&#x3D;ax+[2]&#x3D;C0EA+0012&#x3D;C0FCmov bx,[4]        &#x2F;&#x2F;bx&#x3D;30F0;add bx,[6]        &#x2F;&#x2F;bx&#x3D;bx+[6]&#x3D;31F0+2F30&#x3D;6120\npush ax          &#x2F;&#x2F;将ax&#x3D;C0FC压入栈中;sp&#x3D;sp-2&#x3D;0100-2&#x3D;00FE;                   修改的内存单元的地址是220FE,内容是C0FC                   push bx          &#x2F;&#x2F;将bx&#x3D;6120压入栈中;sp&#x3D;sp-2&#x3D;00FE-2&#x3D;00FC                   修改的内存单元的地址是220FC,内容是6021                   pop ax           &#x2F;&#x2F;将ax&#x3D;C0FC推出栈;sp&#x3D;sp+2&#x3D;00FE;ax&#x3D;6021pop bx           &#x2F;&#x2F;将ax&#x3D;C0FC推出栈;sp&#x3D;sp+2&#x3D;0100;bx&#x3D;C0FCpush [4]         &#x2F;&#x2F;将DS:0004压入栈中;sp&#x3D;sp-2&#x3D;00FE;                   修改的内存单元的地址是220FE,内容是30F0                 push [6]         &#x2F;&#x2F;将DS:0006压入栈中;sp&#x3D;sp-2&#x3D;00FC;                   修改的内存单元的地址是220FC,内容是2F31\n对比实验：\n\n\n\nmov ax,2100mov ds,ax mov ax,2200mov ss,ax mov sp,0100mov ax,[0]          ;ax&#x3D; 3130          add ax,[2]          ;ax&#x3D; 6462            mov bx,[4]          ;bx&#x3D; 3534            add bx,[6]          ;bx&#x3D; 6C6A            push ax             ;sp&#x3D; 00FE                    ;修改的内存单元的地址是2200:FE到FF, 内容为:62 64                push bx             ;sp&#x3D; 00FC                              ;修改的内存单元的地址是2200:FC到FD, 内容为:6A 6C                 pop ax              ;sp&#x3D;00FE   ;ax&#x3D; 6C6A              pop bx              ;sp&#x3D;0100   ;bx&#x3D; 6462            push [4]            ;sp&#x3D; 00FE                             ;修改的内存单元的地址是2200:FE到FF, 内容为:34 35               push [6]            ;sp&#x3D; 00FC                              ;修改的内存单元的地址是2200:FC到FD, 内容为:36 37                \n\n可以看出尽管修改了数据，但是基本的原理都还相同。\n\n程序理解：【1】创建了一个栈的结构，它的实质就是一段连续的内存空间，只不过访问内存的方式不像我们原来的CPU寻址方式，使用push和pop访问。【2】栈使用的实际空间是随着sp指针的指向而发生改变的，它和最大使用空间是有区别的。栈空，sp=100H，栈满，sp=0。【3】栈操作的对象基本单位是字单元（2个字节），对应的内存就是2个内存单元。\n\n\n  (2) 仔细观察图中的实验过程，然后分析：为什么2000:0~2000:f中的内容会发生改变。可能要再做些实验才能发现其中的规律。如果你在这里就正确回答了这个问题，那么要恭喜你，因为你有很好的悟性。大多数的学习者对这个问题还是比较迷惑的，不过不要紧，因为随着课程的进行，这个问题的答案将逐渐变得显而易见。\n\n\n\n前三行指令的功能为：\n\n\n将2000进入ax寄存器中\n\n将ax中的值赋值给ss\n\n将sp的值改为0010。\n\n\n\n变化的原因为：在用t指令进行调试时，会产生中断。cpu将先把标志寄存器进栈，再把当前的cs的值进栈，IP的值最后进栈。\n\n总结体会： 初始没有执行这段代码时，使用d命令观察2000:00内存，都是00，怎么创建栈结构指向这段内存时，我们发现有些数据了。这些数据是什么？\n  发现呢这里面有cs值、ip值、ax值（这个容易看出来），还有bp值（00 00），还有那个一排英文字符。\n  了解一下之后呢，发现：t命令实际是引发了单步中断，执行中断例程时，CPU会将一些中断例程使用的的寄存器变量自动压栈到栈中，此例中就包括了上述的寄存器变量的值。\n注意：由于t命令必须保存寄存器变量的值（这个是中断程序定义的。）它也占用一定的空间。可能我们定义的栈空间比较小；频繁的使用push指令，为了避免栈顶超界，我们尽量使栈空间大些，就像此程序，设定栈空间是100H。\n","categories":["汇编语言"],"tags":["实验","汇编语言"]},{"title":"汇编实验五 编写，调试具有多个段的程序","url":"/2019/03/15/%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E7%BC%96%E5%86%99%EF%BC%8C%E8%B0%83%E8%AF%95%E5%85%B7%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F/","content":"本章的主要内容主要是在讲代码段，数据段，栈段的使用。\n实验1将下面的程序编译，链接，用debug加载，跟踪，然后回答问题。assume cs:code, ds:data, ss:stack data segment\tdw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987hdata ends stack segment\tdw 0, 0, 0, 0, 0, 0, 0, 0stack ends code segmentstart:\tmov ax, stack\tmov ss, ax\tmov sp, 16\t;ss:sp stack \tmov ax, data\tmov ds, ax\t;ds data \tpush ds:[0]\tpush ds:[2]\tpop ds:[2]\tpop ds:[0] \tmov ax, 4c00h\tint 21h code endsend start\n\n\n\ncpu执行程序，程序返回前，data段中的数据是多少？\ncpu执行程序，程序返回前，cs=0042h, ss=076bh, ds=076ah\n设程序加载后，code段的地址为X，则data段的地址 X-2，stack段为X-1。\n\n分析：先用r命令查看，可以看到cx寄存器中的值为42，然后用u命令进行反汇编，因为，代码段已经用start标注，所以可以直接使用u命令，当然，也可以算出代码段的长度之后再反汇编。（代码段长度为42-20=22h）然后g命令，g 001D执行mov ax 4c00h之前的内容，最后用d命令查看内存中的内容，如图：\n实验2将下面的程序编译，链接，用debug加载，跟踪，然后回答问题。assume cs:code, ds:data, ss:stack data segment\tdw 0123h, 0456hdata ends stack segment\tdw 0, 0stack ends code segmentstart:\tmov ax, stack\tmov ss, ax\tmov sp, 16\t;ss:sp stack \tmov ax, data\tmov ds, ax \tpush ds:[0]\tpush ds:[2]\tpop ds:[2]\tpop ds:[0] \tmov ax, 4c00h\tint 21hcode endsend start\n\ncpu执行程序，程序返回前，data段中的数据为多少？\ncpu执行程序，程序返回前，cs=076ch,ss=076bh,ds=076ah.\n设程序加载后，code段的短地址为x，则data段的短地址为x-2，stack段的短地址为x-1。\n对于如下定义的段：name segment…name ends如果段中的数据占N个字节，则程序加载后该段实际占有的空间为（[n/16]+1)*16分析：有了实验1的基础，实验2的操作基本和实验1相同，相同的内容就不赘述了。最主要的不同应该就是定义的数据多少，可能就是要探索关于空间的使用问题。不同的第四个问题，是的，我也不怎么看太明白，看着答案我先简单的推测一下，因为一个段的大小至少为16字节，最大为64k字节，计算地址时有段地址16 的步骤，那么反过来，若段的数据有n字节，则程序加载后，该段实际占有的空间为（n/16+1）16（n/16取整数部分）。还是靠谱的百度一下：详解：\n以下的内容引用于 friendbkf的博客。对于如下定义的段: name segment …. name ends如果段中的数据占N个字节，则程序加载后，该段实际占有的空间为_____.答案：\n  (N/16+1)*16 [说明：N/16只取整数部分]    或   （N＋15）/ 16 ，对16取整\n 在8086CPU架构上，段是以paragraph(16-byte)对齐的。程序默认以16字节为边界对齐，所以不足16字节的部分数据也要填够16字节。“对齐”是alignment，这种填充叫做padding。16字节成一小段，称为节\n\n一、这首先要从8086处理器寻址原理说起。\n8086这种处理器有二十根地址线（20个用于寻址的管脚），可以使用的外部存储器空间可达1MB（00000H～FFFFFH）。 但是，8086内部的寄存器都是16位的，用任何一个寄存器（比如BX或SI），都无法直接寻址8086所支持的1M地址空间，因为16位寄存器只能表示640KB的空间范围（0000～FFFFH）。\n所以，Intel想了一个方法，设计出了CS/DS/ES/SS这几个段地址寄存器，用段地址寄存器与普通寄存器组合，来寻址1MB的地址范围，即：对于CPU取指来说，用CS:IP组合来寻址下一个要执行的指令（也在存储器中）；对于堆栈操作PUSH/POP来说，用SS:SP组合来表示当前栈指针（栈也在存储器中）；对于数据操作指令来说，用默认的DS/ES或指定的段地址（段前缀指令）与偏移量寄存器组合寻址。\n\n组合后的实际地址＝段寄存器内容×16＋偏移量寄存器内容\n从这个公式可以看到，每一个段的地址都对齐在16的倍数上。比如DS=1234H，则这个段就从 1234H×16＋0000H＝12340H开始，最大到1234H×16＋0FFFFH＝2233FH为止。   \n\n二、对同一个内存地址，有不同的段:偏移量组合方法，比如2233FH这个地址，既可以表示为1234H:0FFFFH（在1234H段中），也可以表示为2233H:0000FH（在2233H段中）。那么，如果汇编程序中有下面两个连续的段定义，汇编编译程序会怎么做呢？name1 segmentd1 db 0name1 endsname2 segmentd2 db 0name2 ends　　编译程序可以将name1和name2编译成一个段，d1和d2在内存中连续存放，这样可以节省内存空间。比如编译程序以name1为基准，将name1作为一个段的起始，程序加载后会被放在xxxx0H的地方，那么d1就放在该段偏移地址为0字节的位置，d2就放在该段偏移为1字节的位置。　　这样的处理方式虽然可能会节省一点内存空间，但是对于编译器的智能化要求太高了，它必须将源程序中所有引用到name2和d2的地方，全部调整为以name1段为基准，这实在是太难了，而且也节省不了几个字节的空间，编译器是不会干这种吃力不讨好的事的。\n编译器实际的处理方式是将name1中的所有内容放在一个段的起始地址处，name2里的所有内容放在后续一个段的起始地址处（这也是汇编指令segment的本义：将不同数据分段）。这样，即使name1中只包含一个字节，也要占一个段（16个字节），所以，一个段实际占用的空间＝（段中字节数＋15）/ 16。\n\n　　所以，8086处理器的内部寻址原理和汇编程序编译器共同决定了segment定义的段必须放在按16的倍数对准的段地址边界上，占用的空间也是16的倍数。\n\n\n\n\n实验3将下面的程序编译，链接，用debug加载，跟踪，然后回答问题。assume cs:code, ds:data, ss:stack code segmentstart:\tmov ax, stack\tmov ss, ax\tmov sp, 16\t;ss:sp stack \tmov ax, data\tmov ds, ax \tpush ds:[0]\tpush ds:[2]\tpop ds:[2]\tpop ds:[0] \tmov ax, 4c00h\tint 21h \tdata segment\tdw 0123h, 0456h\tdata ends \tstack segment\t\tdw 0, 0\tstack ends code endsend start\n\nCPU执行程序，程序返回前，data段中的数据为多少？\nCPU执行程序，程序返回前，cs=076ch,ss=076eh__，ds=__076dh.\n设程序加载后，code段的短地址为x，则data段的短地址为__x+3__，stack段的短地址为__x+4__。\n\n分析：操作几乎都和实验1，2一样，不赘述了。\n\n实验4如果将（1），（2），（3）题中的最后一条伪指令end start改为end（也就是说，不指明程序的入口个），则哪个程序仍然可以正确执行？请说明原因。第三个程序仍然可以执行，因为不指明程序入口时，cs:code segment默认ip为0，第三个程序正好是程序开始的地方，前两个ip=0开始的地方存的是数据，解析为汇编指令是错误的。也就明白什么时候用end，什么时候用end start。\n实验5程序如下，编写code段中的代码，用push指令将a段和b段中的数据依次相加，将结果存到c段中。assume cs:codea segment    db 1,2,3,4,5,6,7,8a ends                 b segment     db 1,2,3,4,5,6,7,8b ends c segment    db 0,0,0,0,0,0,0,0c ends  code segmentstart:     mov ax,a     mov ds,ax      mov bx,0     mov cx,4 s:   mov dx,ds:[bx]     add dx,ds:[bx+16]     mov ds:[bx+32],dx     add bx,2     loop s          mov ax,4c00h     int 21h     code endsend start\n分析：思路：将a段的数据先存在dx中，然后直接用b段数据相加，然后再将相加后的结果给c。若a的段地址为x，则b的段地址为x+1，c的段地址为x+2。\n\n很明显，相加成功了。这里有一个问题，a b段的数据不是很大 ，相加之后还是小于255，所以不会溢出。如果溢出应该怎么解决呢?\n实验6程序如下，编写code段中的代码，用push指令将a段中的前8个字型数据，逆序存储到b段中。assume cs:codea segment    dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffha ends                 b segment     dw 0,0,0,0,0,0,0,0b ends code segment    start:          mov ax,a          mov ds,ax          mov ax,b          mov ss,ax          mov sp,10h          mov bx,0          mov cx,8          s:        push ds:[bx]          add bx,2          loop s                  mov ax,4c00h          int 21h           code endsend start\n分析：记得课上好像讲过类似的。\n\n很明显，b的8个字单元为a段前8个字节的逆序。\n注意：dw 是定义的字型数据，每个数据16个位，两个字节。db是定义的字节型数据，每个数据8位，一个字节。段寄存器之间不能直接转移数据，需要通过al寄存器来中转。\n不得不说，本次耗费的时间比想像中要长很多。希望下次不会这么慢了，还是多多练习吧。\n","categories":["汇编语言"],"tags":["实验","汇编语言"]},{"title":"汇编实验八 分析一个奇怪的程序","url":"/2019/03/30/%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C%E5%85%AB%20%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E7%A8%8B%E5%BA%8F/","content":"分析程序，在运行前思考：这个程序是否能够正确返回？运行之后再思考：为什么是这种结果？通过这个程序加深对相关内容的理解。\nassueme cs:codesgcodesg segment        mov ax,4c00h        int 21hstart:  mov ax,0    s:  nop        nop        mov di,offset s        mov si,offset s2        mov ax,cs:[si]        mov cs:[di],ax    s0: jmp short s    s1: mov ax,0        int 21h        mov ax,0    s2: jmp short s1        nopcodesg endsend start\n分析：\nstart: mov ax,0\n    s: nop  ; nop标号语句，在运行时在代码段中分配一个字节的空间，\n       nop  ; 这个字节（空间）的值为90h。\n        \n            ; 操作符 `offset` 的功能是取得标号的偏移地址。\n       mov di,offset s   ;将 s 的偏移地址存到 di 寄存器中\n       mov si,offset s2  ;将 s2 的偏移地址存到 si 寄存器中\n       mov ax,cs:[si]    ;此行是将cs:[si]内存中的机器码存到ax寄存器中\n                         ;这个机器码是由编译器将s2标号字段中的指令编译而成\n       mov cs:[di],ax    ;将ax中的s2标号字段的机器码存放到s标号字段中\n   s0: jmp short s       ;跳转到 s 标号字段处执行代码。\n\n   s:  jmp short s1 ; 根据我们之前的分析, 指令是用相对偏移来表示的\n    ; 因此执行的操作并不是真的跳转到 s1 这个标号, \n    ; 而是跳转编译时确定的 该指令到 s1 标号的偏移量。\n    ; 所以我们要分析接下来程序的流程的话 , 就必须先编译程序 , \n    ; 通过查看这条指令的机器代码，才知道偏移量是多少。\n    ; 然后再根据这个偏移量确定程序下一步应该执行哪里的指令。\n    ; 根据下图的编译结果 , 可以发现 , \n    ; jmp short s1 在编译后得到的指令是 : EB F6\n    ; 由上可知，偏移量是 :F6 \n    ; 偏移量是由 补码 来表示的，由书中 附注二 ，\n    ; 我们可以算出 F6对应的有符号十进制数为 -10。\n    ; 从这里，我们可以知道，这条指令是将 ip 的值加上 -10。\n    ; 那么，我们再看看 ip - 10 指向的地址是哪里呢 ? \n    ; 由下图的编译结果，我们可以知道，\n    ; 它指向的刚好就是 code segment 开始的位置.\n    mov ax,4c00h\n    int 21h      ;看到这两句，大家就知道，程序是可以正常返回了\n\n","categories":["汇编语言"],"tags":["实验","汇编语言"]},{"title":"汇编实验四 【bx】和loop的使用","url":"/2019/03/12/%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C%E5%9B%9B%20%E3%80%90bx%E3%80%91%E5%92%8Cloop%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"\n实验内容1:综合使用 loop,[bx]，编写完整汇编程序，实现向内存 b800:07b8 开始的连续 16 个 字单元重复填充字数据 0403H。\n\n(1)源代码：代码实现：\n进行编译，链接，运行之后屏幕的确出现了所示的截图。\n(2)将源代码程序中字数据 0403H→修改为 0441H，再次运行，截图显示运行结果。\n很明显，改变数值后相应位置上的对应图案随之改变了。\n\n实验内容 2(必做部分)综合使用 loop,[bx]，编写完整汇编源程序，实现向内存 0:200~ 0:23F 依次传送数据 0 ~ 63(3FH 综合使用 loop,[bx]，编写完整汇编源程序，实现向内存 0:200~ 0:23F 依次传送数据 0 ~ 63(3FH）(1)源代码：\n\n(2)汇编、链接无误后，灵活使用 debug 的 t 命令、g 命令、p 命令调试，用 d 命令查看 0:200  ~ 0:23F，确认是否将 0~63 传送至此段内存区域。这部分，要求有截图。 (选做部分，如完成，也按上述要求在博客文档中撰写相应内容)编译后g，u命令:\nd命令查看内存：\nt命令进行查看（就只放一张了）\n\n教材实验 4(3)(P121)下面的程序的功能是将”mov ax,4c00h”之前的指令复制到内存0:200处，补全程序，上机调试，跟踪运行结果 \n\nassume cs:codecode segment    mov ax,_______    mov ds,ax    mov ax,0020h    mov es,ax    mov bx,0    mov cx,_______  s:mov al,[bx]    mov es:[bx],al    inc bx    loop s        mov ax,4c00h    int 21hcode endsend\n (1)源代码： 分析：第一个空，没有疑问。填code。即把代码段内的指令当作数据，复制到目的地址。源数据段与ds与代码段code相同。当然，cx也没有问题，不过，要注意的是code占用3个字节，cx占用两个字节。第二个空，上面说先给code一个小值。编译链接后用debug看code中的值。然后再减去5h。我r查看cx为1d，所以应该填18h。(使用es来存放目标空间的段地址，用ds存放原始空间的段地址，避免了在循环中一直重置ds) \nassume cs:codecode segment    mov ax,(code)     ;因为要复制的内容是指令，所以，数据段应与代码段同段    mov ds,ax    mov ax,0020h    mov es,ax    mov cx,(18h)      ;&quot;mov ax,4c00h&quot;之前的指令共24个字节    mov bx,0s: mov al,[bx]    mov es:[bx],al    inc bx    loop s        mov ax,4c00h    int 21hcode endsend\n (2)汇编连接后，灵活使用 debug 的 t 命令、g 命令、p 命令调试，用 d 命令查看 0:200 之后的若干字节，观察是否将 mov ax, 4c00h 之前的指令复制到指定内存，这部分要求有截 图，并以文字方式说明空白处填写依据。\n \n\n观察上下这两个图，确实“mov ax 4c00h”之前的指令复制到了0：200处\n\n\n实验小结：\n\n在汇编程序中，数据不能以字母开头，要在前面加0.\n一些指令的使用还是不怎么熟练，思路有些混乱。哦豁，完蛋。\n\n","categories":["汇编语言"],"tags":["实验","汇编语言"]},{"title":"第四章知识总结","url":"/2019/03/02/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","content":"一个汇编语言程序从写出到最终执行的简要过程：1、编写：使用文本编译器（如记事本、Nodpad、UltraEdit），用汇编语言编写汇编源程序。2、编译连接：使用汇编语言编译程序（MASM.EXE）对源程序文件中的源程序进行编译，产生目标文件；再用连接程序（LINK.EXE）对目标文件进行连接，生成可在操作系统中直接运行的可执行文件。可执行文件包含两部分内容：（1）程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）（2）相关的描述信息（比如，程序有多大、要占用多少内存空间等）3、执行可执行文件中的程序在操作系统中，执行可执行文件中的程序。操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如设置CS:IP指向第一条要执行的指令），然后由CPU执行程序。\n\n伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须用到的一对伪指令。它们的功能是定义一个段，segment说明一个段开始，ends说明一个段结束。\n   一个段必须有一个名称来标识，使用格式为：   段名 segment   段名 ends   一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。\n   一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。End是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译。\n   如果程序写完了，要在结尾处加上伪指令end。否则，编译器在编译程序时，无法知道程序在何处结束。\n\n\n不要把end和ends搞混了。\n\n寄存器和段的关联假设：assume：含义为“假设”。它假设某一段寄存器和程序中的某一个用segment……ends定义的段相关联。通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。\n\n源程序中的程序：汇编源程序：汇编源程序：\n伪指令  （编译器处理）\n            汇编指令（编译为机器码）\n\n\n程序返回应该在程序的末尾添加返回的程序段。   mov ax,4c00H   int 21H (中断DOS）这两条指令所实现的功能就是程序返回。我们用汇编语言编写好程序后，要将后缀名改为asm，然后再把程序和下载的masm中的link.exe、masm.exe和ml.exe放在一起，然后通过cmd命令找到文件路径，再进行编译连接，如：masm 1.asm，link 1.obj。\n\nexe的执行：我们刚才写的的程序没有向显示器输出任何信息。程序只是做了一些将数据送入寄存器和加法的操作，而这些事情，我们不可能从显示屏上看出来。程序执行完成后，返回，屏幕上再次出现操作系统的提示符。\n\n\n以简化的方式进行编译和连接直接再cmd中输入ml 1.asm就可以生成1.exe文件\n这里1.asm是已经编辑好的源程序\n关于编译和链接\n连接的作用是什么？\n连接的作用有以下几个：\n当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件；\n程序中调用了某个库文件的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件；   一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将此内容处理为最终的可执行信息。\n所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。\n注意：对于连接的过程，可执行文件是我们要得到的最终结果。\n我们用汇编语言编程，就要用到：编辑器（Edit）、编译器（masm）、连接器（link）、调试工具（debug）等所有工具，而这些工具都是在操作系统之上运行的程序，所以我们的学习过程必须在操作系统的环境中进行。\n操作系统的外壳：    操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统，都要提供一个称为shell（外壳）的程序，用户（操作人员）使用这个程序来操作计算机系统工作。\n为了观察程序的运行过程，我们可以使用Debug。Debug可以将程序加载入内存，设置CS:IP指向程序的入口，但Debug并不放弃对CPU的控制，这样，我们就可以使用Debug的相关命令来来单步执行程序，查看每条指令的执行结果。debug相当于执行一条程序的指令然后马上中断一次。\n程序加载后，DS中存放这程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为：ds:0；\n这个内存区的前256个字节中存放的是PSP，dos用来和程序进行通信。\n从256字节处向后的空间存放的是程序。\n所以，我们从ds中可以得到PSP的段地址SA，PSP的偏移地址为0，则物理地址为SAx16+0\n因为PSP占256（100H）字节，所以程序的物理地址是：\nSAX16+0+256=SAX16+16X16=(SA+16)X16+0\n可用段地址和偏移地址表示为：SA+10:0。\n可以用U命令查看一下其他指令；\n可以用T命令单步执行程序中的每一条指令并观察每条指令的执行结果\n到了int 21，我们要用P命令执行\nint 21执行后，显示”Program terminated normally“，返回到debug中。\n表示程序正常结束。\n这里要再强调一次：要用P命令执行int 21。\n需要注意的是，在DOS中运行程序时，是command将程序加载入内存；\n所以程序运行结束后，返回到command中，而在这里是debug将程序加载入内存，所以程序运行结束后要返回到Debug中。\n使用Q命令退出Debug，将返回到command中，因为Debug是由command加载运行的。\n我们在DOS中用debug 1.exe运行debug对1.exe进行跟踪时，程序加载的顺序是：command加载debug，debug加载1.exe。\n返回的顺序是：从1.exe中的程序返回到Debug，从Debug返回到command。\n","categories":["汇编语言"],"tags":["汇编语言"]}]